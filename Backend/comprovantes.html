<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Upload de Comprovantes</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
body{font-family:Arial;background:#f5f5f5;padding:40px}
.card{background:#fff;border-radius:12px;padding:24px;max-width:1100px;margin:auto;box-shadow:0 0 30px rgba(0,0,0,.08)}
button{background:#1f6feb;color:#fff;border:none;padding:10px 18px;border-radius:8px;cursor:pointer}
button.sec{background:#111827}
button.warn{background:#b45309}
button.ghost{background:#eef2ff;color:#1f6feb}
button:disabled{opacity:.6;cursor:not-allowed}
.status{white-space:pre-wrap;margin-top:15px;font-size:13px;background:#f3f4f6;padding:10px;border-radius:10px}
img{max-width:100%;margin-top:15px;border-radius:8px}
a{display:inline-block;margin-top:12px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px}
table{width:100%;border-collapse:collapse;margin-top:14px;background:#fff;border-radius:10px;overflow:hidden}
th,td{padding:10px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top}
th{background:#f9fafb;font-weight:700}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef2ff;color:#1f6feb;font-size:12px}
.small{font-size:12px;color:#6b7280}
.actions{display:flex;gap:8px;flex-wrap:wrap}
input[type="file"]{max-width:100%}
input[type="text"]{padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;min-width:260px}
.tagpill{display:inline-block;background:#f3f4f6;border:1px solid #e5e7eb;border-radius:999px;padding:2px 8px;font-size:12px;margin:2px 4px 0 0}
.tagsCell{max-width:360px}
.hint{font-size:12px;color:#6b7280;margin-top:4px}
hr{border:none;border-top:1px solid #e5e7eb;margin:14px 0}
</style>
</head>
<body>

<script>
  // FORÇA WWW (evita sessão sumir por origem diferente)
  if (location.hostname === "colorglassfortaleza.com.br") {
    location.replace("https://www.colorglassfortaleza.com.br" + location.pathname + location.search + location.hash);
  }
</script>

<div class="card">
  <h2>Enviar comprovante + Tags</h2>

  <div class="row">
    <button id="login">Entrar com GitHub</button>
    <button id="logout" class="sec">Logout</button>
    <button id="reset" class="warn" type="button">RESET AUTH</button>
    <button id="listar" type="button">Listar arquivos</button>
  </div>

  <p id="auth" class="small"></p>

  <div class="row">
    <input type="file" id="file" accept="image/*,application/pdf">
    <button id="upload">Enviar</button>
  </div>

  <div class="row">
    <input type="text" id="tagsInput" placeholder="Tags para o PRÓXIMO upload (ex: cozinha, bronze, 1036)">
    <button id="salvarUltimo" class="ghost" type="button">Salvar tags do ÚLTIMO upload</button>
  </div>
  <div class="hint">As tags são salvas na tabela <b>imagetags</b> usando <b>id = fullPath</b> (ex: userId/arquivo.jpg).</div>

  <hr>

  <div class="row">
    <input type="text" id="searchTag" placeholder="Buscar por tag (ex: bronze)">
    <button id="buscar" type="button">Buscar</button>
    <button id="limparBusca" class="sec" type="button">Limpar busca</button>
  </div>

  <div id="listaWrap"></div>

  <p class="status" id="status"></p>
</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const SUPABASE_URL = "https://hfhwvzldhgqniqnurync.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_0j-jqB63odD2yvugj7olMA_s18OwuPl";

const supabase = createClient(
  SUPABASE_URL,
  SUPABASE_ANON_KEY,
  { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true } }
);

const BUCKET = "comprovantes";
const REDIRECT = "https://www.colorglassfortaleza.com.br/callback.html";
const TAGS_TABLE = "imagetags";

const auth = document.getElementById("auth");
const status = document.getElementById("status");
const listaWrap = document.getElementById("listaWrap");
const tagsInput = document.getElementById("tagsInput");
const salvarUltimoBtn = document.getElementById("salvarUltimo");
const searchTag = document.getElementById("searchTag");

let lastUploadedPath = null; // guarda o fullPath (userId/arquivo) do último upload

function safeName(n){
  return (n || "comprovante")
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g,"")
    .replace(/[^a-zA-Z0-9._-]/g,"_");
}

function setStatus(txt){ status.innerText = txt || ""; }
function append(txt){ status.innerText += (txt || "") + "\n"; }

function parseTags(str){
  return (str || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean)
    .map(s => s.toLowerCase());
}

function bytesToHuman(bytes){
  if (bytes == null) return "-";
  const units = ["B","KB","MB","GB"];
  let i = 0;
  let v = Number(bytes);
  while (v >= 1024 && i < units.length-1){ v /= 1024; i++; }
  return (i === 0 ? v : v.toFixed(2)) + " " + units[i];
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function sbLocalStorageInfo(){
  const keys = Object.keys(localStorage);
  const sbKeys = keys.filter(k => k.includes("sb-") || k.includes("supabase"));
  const tokenKey = sbKeys.find(k => k.includes("-auth-token")) || null;

  let raw = null, parsed = null, access_token = null;
  try {
    raw = tokenKey ? localStorage.getItem(tokenKey) : null;
    parsed = raw ? JSON.parse(raw) : null;
    access_token = parsed?.access_token || parsed?.currentSession?.access_token || null;
  } catch (e) {}

  return { sbKeys, tokenKey, access_token_exists: !!access_token, access_token };
}

window.addEventListener("unhandledrejection", (e) => {
  append("UNHANDLED REJECTION: " + (e?.reason?.message || e?.reason || e));
  console.error("unhandledrejection", e);
});
window.addEventListener("error", (e) => {
  append("WINDOW ERROR: " + (e?.message || e));
  console.error("window error", e);
});

async function manualAuthUserCheck(){
  const info = sbLocalStorageInfo();
  append("MANUAL CHECK: access_token exists? " + info.access_token_exists);

  if(!info.access_token){
    append("MANUAL CHECK: sem access_token no localStorage.");
    return;
  }

  try{
    const r = await fetch(`${SUPABASE_URL}/auth/v1/user`, {
      method: "GET",
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: "Bearer " + info.access_token
      }
    });
    const txt = await r.text();
    append("MANUAL /auth/v1/user STATUS=" + r.status);
    append(txt);
  } catch (e) {
    append("MANUAL /auth/v1/user THROW: " + (e?.message || e));
    console.error("manual user throw", e);
  }
}

async function refresh(){
  setStatus("");

  append("REFRESH AUTH...");
  append("HOST=" + location.host);
  append("ORIGIN=" + location.origin);
  append("");

  const info = sbLocalStorageInfo();
  append("LS KEYS:");
  append(info.sbKeys.length ? info.sbKeys.join("\n") : "(vazio)");
  append("");
  append("TOKEN KEY: " + (info.tokenKey || "(nenhuma)"));
  append("ACCESS TOKEN EXISTS? " + info.access_token_exists);
  append("");

  try {
    const sess = await supabase.auth.getSession();
    append("getSession OK");
    append(JSON.stringify(sess, null, 2));
    append("");
  } catch (e) {
    append("getSession THROW: " + (e?.message || e));
    append("");
    console.error("getSession throw", e);
  }

  try {
    const u = await supabase.auth.getUser();
    append("getUser OK");
    append(JSON.stringify(u, null, 2));
    append("");
    const user = u?.data?.user;

    if(user){
      auth.innerText = "Logado: " + (user.email || user.user_metadata?.user_name || user.id);
    } else {
      auth.innerText = "Não logado";
    }
  } catch (e) {
    auth.innerText = "Não logado (erro getUser)";
    append("getUser THROW: " + (e?.message || e));
    append("");
    console.error("getUser throw", e);
  }

  await manualAuthUserCheck();
}

// ---------- STORAGE OPEN ----------
async function openObject(path){
  const signed = await supabase.storage.from(BUCKET).createSignedUrl(path, 600);
  if (!signed.error && signed.data?.signedUrl){
    window.open(signed.data.signedUrl, "_blank", "noopener");
    return;
  }

  const dl = await supabase.storage.from(BUCKET).download(path);
  if (dl.error){
    append("OPEN ERROR (signed+download): " + dl.error.message);
    return;
  }

  const blobUrl = URL.createObjectURL(dl.data);
  window.open(blobUrl, "_blank", "noopener");
  setTimeout(() => URL.revokeObjectURL(blobUrl), 60_000);
}

// ---------- TAGS (imagetags: id text, tais jsonb) ----------
async function upsertTagsForId(id, tagsArr){
  const payload = {
    id,
    tais: {
      tags: tagsArr,
      updated_at: new Date().toISOString()
    }
  };

  const res = await supabase.from(TAGS_TABLE).upsert(payload, { onConflict: "id" }).select("id,tais").single();
  append("TAGS UPSERT RESULT:");
  append(JSON.stringify(res, null, 2));
  append("");
  return res;
}

async function getTagsForIds(ids){
  // Busca em lote
  if(!ids.length) return new Map();
  const res = await supabase.from(TAGS_TABLE).select("id,tais").in("id", ids);
  append("TAGS BATCH SELECT:");
  append(JSON.stringify(res, null, 2));
  append("");

  const map = new Map();
  if(!res.error && Array.isArray(res.data)){
    for(const row of res.data){
      const t = row?.tais?.tags;
      map.set(row.id, Array.isArray(t) ? t : []);
    }
  }
  return map;
}

async function findIdsByTag(tag){
  // JSONB contains: tais @> {"tags":["tag"]}
  const res = await supabase.from(TAGS_TABLE).select("id,tais").contains("tais", { tags: [tag] }).limit(200);
  append("TAGS SEARCH contains tais.tags:");
  append(JSON.stringify(res, null, 2));
  append("");
  if(res.error) return [];
  return (res.data || []).map(r => r.id);
}

// ---------- LISTAGEM EM TABELA + TAGS ----------
function renderTags(tags){
  if(!tags || !tags.length) return `<span class="small">(sem tags)</span>`;
  return tags.map(t => `<span class="tagpill">${escapeHtml(t)}</span>`).join("");
}

function renderTable(folder, files, tagsMap, filteredIdsSet=null){
  let html = `
    <div class="row" style="justify-content:space-between;margin-top:16px">
      <div><span class="badge">Pasta</span> <b>${escapeHtml(folder)}/</b></div>
      <div class="small">${files.length} arquivo(s)</div>
    </div>

    <table>
      <thead>
        <tr>
          <th>Arquivo</th>
          <th>Tamanho</th>
          <th>Atualizado</th>
          <th>Tipo</th>
          <th>Tags</th>
          <th>Ações</th>
        </tr>
      </thead>
      <tbody>
  `;

  for(const f of files){
    const name = f.name;
    const size = bytesToHuman(f.metadata?.size ?? f.metadata?.contentLength ?? null);
    const updated = f.updated_at || f.created_at || "";
    const mime = f.metadata?.mimetype || f.metadata?.contentType || "-";
    const fullPath = `${folder}/${name}`;

    // se estiver em modo filtro por tag, esconde o que não está no set
    if(filteredIdsSet && !filteredIdsSet.has(fullPath)) continue;

    const tags = tagsMap.get(fullPath) || [];

    html += `
      <tr>
        <td><b>${escapeHtml(name)}</b><div class="small">${escapeHtml(fullPath)}</div></td>
        <td>${escapeHtml(size)}</td>
        <td>${escapeHtml(updated)}</td>
        <td>${escapeHtml(mime)}</td>

        <td class="tagsCell">
          <div data-tags-view="${escapeHtml(fullPath)}">${renderTags(tags)}</div>
          <div class="row" style="margin-top:8px">
            <input type="text" data-tags-input="${escapeHtml(fullPath)}" placeholder="ex: cozinha, bronze, 1036" style="min-width:240px">
            <button type="button" class="ghost" data-save-tags="${escapeHtml(fullPath)}">Salvar</button>
          </div>
        </td>

        <td class="actions">
          <button type="button" data-open="${escapeHtml(fullPath)}">Abrir</button>
        </td>
      </tr>
    `;
  }

  html += `</tbody></table>`;
  listaWrap.innerHTML = html;

  // abrir
  listaWrap.querySelectorAll("button[data-open]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const p = btn.getAttribute("data-open");
      append("OPEN: " + p);
      await openObject(p);
    });
  });

  // salvar tags por arquivo
  listaWrap.querySelectorAll("button[data-save-tags]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const id = btn.getAttribute("data-save-tags");
      const inp = listaWrap.querySelector(`input[data-tags-input="${CSS.escape(id)}"]`);
      const tagsArr = parseTags(inp?.value || "");
      append("SAVE TAGS id=" + id);
      append("TAGS=" + JSON.stringify(tagsArr));
      const res = await upsertTagsForId(id, tagsArr);
      if(res.error){
        append("SAVE TAGS ERROR: " + res.error.message);
        return;
      }
      // atualiza UI sem refazer tudo
      const view = listaWrap.querySelector(`div[data-tags-view="${CSS.escape(id)}"]`);
      if(view) view.innerHTML = renderTags(tagsArr);
    });
  });
}

async function listMyFiles(filterByIds=null){
  await refresh();

  const u = await supabase.auth.getUser().catch(()=>({}));
  const user = u?.data?.user;
  if(!user){
    listaWrap.innerHTML = `<p class="small">Faça login para listar.</p>`;
    return;
  }

  const folder = user.id;
  append("LIST START folder=" + folder);

  const res = await supabase.storage.from(BUCKET).list(folder, {
    limit: 100,
    offset: 0,
    sortBy: { column: "updated_at", order: "desc" }
  });

  append("LIST RESULT:");
  append(JSON.stringify(res, null, 2));
  append("");

  if(res.error){
    listaWrap.innerHTML = `
      <p class="small" style="color:#b91c1c">
        Erro ao listar: ${escapeHtml(res.error.message)}
      </p>`;
    return;
  }

  const files = res.data || [];
  if(!files.length){
    listaWrap.innerHTML = `<p class="small">Nenhum arquivo encontrado em <b>${escapeHtml(folder)}/</b>.</p>`;
    return;
  }

  // carregar tags em lote (ids = fullPath)
  const ids = files.map(f => `${folder}/${f.name}`);
  const tagsMap = await getTagsForIds(ids);

  const filteredIdsSet = filterByIds ? new Set(filterByIds) : null;
  renderTable(folder, files, tagsMap, filteredIdsSet);
}

// ---------- BOTÕES ----------
document.getElementById("login").onclick = async ()=>{
  setStatus("CLICK LOGIN...\n");
  const { error } = await supabase.auth.signInWithOAuth({
    provider: "github",
    options: { redirectTo: REDIRECT }
  });
  if(error){
    append("OAUTH ERROR:");
    append(error.message);
    console.error(error);
    alert(error.message);
  } else {
    append("REDIRECTING...");
  }
};

document.getElementById("logout").onclick = async ()=>{
  await supabase.auth.signOut();
  listaWrap.innerHTML = "";
  await refresh();
};

document.getElementById("reset").onclick = async ()=>{
  setStatus("RESET AUTH...\n");
  try{ await supabase.auth.signOut(); } catch(e){}
  const keys = Object.keys(localStorage).filter(k => k.includes("sb-") || k.includes("supabase"));
  keys.forEach(k => localStorage.removeItem(k));
  append("REMOVIDAS KEYS:\n" + (keys.length ? keys.join("\n") : "(nenhuma)"));
  append("\nRELOAD...");
  location.reload();
};

document.getElementById("listar").onclick = async ()=>{ await listMyFiles(); };

// buscar por tag (filtra a tabela)
document.getElementById("buscar").onclick = async ()=>{
  await refresh();
  const tag = (searchTag.value || "").trim().toLowerCase();
  if(!tag){
    append("BUSCA: digite uma tag.");
    return;
  }
  append("BUSCA TAG=" + tag);
  const ids = await findIdsByTag(tag);
  if(!ids.length){
    listaWrap.innerHTML = `<p class="small">Nenhum arquivo encontrado com a tag <b>${escapeHtml(tag)}</b>.</p>`;
    return;
  }
  await listMyFiles(ids);
};

document.getElementById("limparBusca").onclick = async ()=>{
  searchTag.value = "";
  await listMyFiles();
};

// salvar tags do último upload
salvarUltimoBtn.onclick = async ()=>{
  await refresh();
  if(!lastUploadedPath){
    append("Nenhum upload recente para salvar tags.");
    return;
  }
  const tagsArr = parseTags(tagsInput.value);
  append("SAVE LAST UPLOAD TAGS path=" + lastUploadedPath);
  append("TAGS=" + JSON.stringify(tagsArr));
  const res = await upsertTagsForId(lastUploadedPath, tagsArr);
  if(res.error){
    append("SAVE TAGS ERROR: " + res.error.message);
    return;
  }
  append("OK: tags salvas para " + lastUploadedPath);
  await listMyFiles();
};

// ---------- UPLOAD (MANTIDO IGUAL AO SEU) ----------
document.getElementById("upload").onclick = async ()=>{
  // ⚠️ Não mexi no upload, só deixei como você tinha
  // (mantém o comportamento original)
  await refresh();

  const u = await supabase.auth.getUser().catch(()=>({}));
  const user = u?.data?.user;

  if(!user){
    append("UPLOAD BLOQUEADO: não logado.");
    return;
  }

  const file = document.getElementById("file").files[0];
  if(!file){
    append("UPLOAD BLOQUEADO: selecione um arquivo.");
    return;
  }

  const path = user.id + "/" + crypto.randomUUID() + "_" + safeName(file.name);
  append("UPLOAD START");
  append("PATH=" + path);

  const up = await supabase.storage.from(BUCKET).upload(path, file);
  append("UPLOAD RESULT:");
  append(JSON.stringify(up, null, 2));
  append("");

  if(up.error){
    append("UPLOAD ERROR: " + up.error.message);
    return;
  }

  const signed = await supabase.storage.from(BUCKET).createSignedUrl(path, 600);
  append("SIGNED RESULT:");
  append(JSON.stringify(signed, null, 2));
  append("");

  if(signed.error){
    append("SIGNED ERROR: " + signed.error.message);
    return;
  }

  append("SIGNED URL OK");

  // ✅ NOVO: guarda o lastUploadedPath, mas sem mexer no upload em si
  lastUploadedPath = path;
  append("LAST UPLOAD SET: " + lastUploadedPath);

  // ✅ opcional: se você quiser salvar tags automaticamente do input (descomenta)
  // const tagsArr = parseTags(tagsInput.value);
  // if(tagsArr.length){
  //   await upsertTagsForId(lastUploadedPath, tagsArr);
  //   append("AUTO TAGS OK");
  // }

  // ✅ opcional: refresh da lista após upload
  // await listMyFiles();
};

await refresh();
supabase.auth.onAuthStateChange(async (event) => {
  append("AUTH STATE CHANGE: " + event);
  await refresh();
});
</script>
</body>
</html>











