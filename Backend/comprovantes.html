<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Upload + Tags | ColorGlass</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<style>
  :root{
    --bg:#0b1020;
    --panel:#0f172a;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.04);
    --border:rgba(255,255,255,.10);
    --text:#e5e7eb;
    --muted:#9ca3af;
    --accent:#3b82f6;
    --accent2:#22c55e;
    --warn:#f59e0b;
    --danger:#ef4444;
    --shadow: 0 24px 80px rgba(0,0,0,.55);
    --radius: 18px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--text);
    background:
      radial-gradient(1000px 700px at 10% 15%, rgba(59,130,246,.24), transparent 60%),
      radial-gradient(900px 600px at 85% 20%, rgba(34,197,94,.18), transparent 60%),
      radial-gradient(1200px 700px at 50% 90%, rgba(245,158,11,.12), transparent 65%),
      linear-gradient(180deg, var(--bg), #050815);
    padding:42px 18px;
  }
  .wrap{max-width:1180px;margin:0 auto}
  .topbar{
    display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap;
    margin-bottom:16px;
  }
  .brand{
    display:flex;align-items:center;gap:12px;
    padding:10px 14px;border:1px solid var(--border);
    border-radius:999px;background:rgba(255,255,255,.03);
    backdrop-filter: blur(10px);
  }
  .dot{
    width:12px;height:12px;border-radius:50%;
    background: linear-gradient(180deg, var(--accent), rgba(59,130,246,.35));
    box-shadow: 0 0 0 5px rgba(59,130,246,.12);
  }
  .brand h1{
    font-size:14px;margin:0;letter-spacing:.5px;font-weight:800;
  }
  .brand span{color:var(--muted);font-size:12px}

  .card{
    border:1px solid var(--border);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    box-shadow: var(--shadow);
    overflow:hidden;
  }

  .cardHead{
    padding:18px 18px 10px 18px;
    display:flex;align-items:flex-start;justify-content:space-between;gap:14px;flex-wrap:wrap;
  }
  .title{
    display:flex;flex-direction:column;gap:6px;
  }
  .title h2{
    margin:0;
    font-size:18px;
    letter-spacing:.3px;
  }
  .title p{margin:0;color:var(--muted);font-size:13px;line-height:1.4}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;border:1px solid var(--border);
    background:rgba(255,255,255,.03);
    color:var(--muted);font-size:12px;
  }
  .pill b{color:var(--text)}

  .cardBody{padding:14px 18px 18px 18px}

  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .row + .row{margin-top:10px}

  button{
    border:none;
    padding:10px 14px;
    border-radius:12px;
    font-weight:800;
    letter-spacing:.2px;
    cursor:pointer;
    color:white;
    background: linear-gradient(180deg, rgba(59,130,246,1), rgba(59,130,246,.78));
    box-shadow: 0 10px 28px rgba(59,130,246,.22);
    transition: transform .08s ease, filter .15s ease;
  }
  button:hover{filter:brightness(1.06)}
  button:active{transform: translateY(1px)}
  button:disabled{opacity:.55;cursor:not-allowed;box-shadow:none}

  button.sec{
    background: linear-gradient(180deg, rgba(148,163,184,.35), rgba(148,163,184,.18));
    box-shadow:none;color:var(--text);
    border:1px solid var(--border);
  }
  button.warn{
    background: linear-gradient(180deg, rgba(245,158,11,1), rgba(245,158,11,.78));
    box-shadow: 0 10px 28px rgba(245,158,11,.18);
  }
  button.ghost{
    background: rgba(255,255,255,.04);
    border:1px solid var(--border);
    color: var(--text);
    box-shadow:none;
  }
  button.good{
    background: linear-gradient(180deg, rgba(34,197,94,1), rgba(34,197,94,.72));
    box-shadow: 0 10px 28px rgba(34,197,94,.15);
  }

  input[type="text"], input[type="file"]{
    padding:11px 12px;
    border-radius:12px;
    border:1px solid var(--border);
    background: rgba(255,255,255,.04);
    color: var(--text);
    outline:none;
  }
  input[type="text"]::placeholder{color: rgba(156,163,175,.85)}
  input[type="text"]{min-width:280px}
  .hint{
    margin-top:10px;
    color:var(--muted);
    font-size:12px;
    padding:10px 12px;
    border-radius:14px;
    border:1px dashed rgba(255,255,255,.14);
    background: rgba(255,255,255,.03);
  }

  .status{
    margin-top:14px;
    white-space:pre-wrap;
    font-size:12px;
    line-height:1.45;
    color: rgba(229,231,235,.92);
    background: rgba(2,6,23,.55);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:12px;
    max-height: 340px;
    overflow:auto;
  }

  table{
    width:100%;
    border-collapse:collapse;
    margin-top:14px;
    border:1px solid var(--border);
    border-radius: 16px;
    overflow:hidden;
    background: rgba(255,255,255,.03);
  }
  thead th{
    text-align:left;
    font-size:12px;
    color: rgba(229,231,235,.85);
    padding:12px;
    background: rgba(255,255,255,.04);
    border-bottom:1px solid var(--border);
  }
  tbody td{
    padding:12px;
    font-size:12px;
    border-bottom:1px solid rgba(255,255,255,.08);
    vertical-align:top;
    color: rgba(229,231,235,.92);
  }
  tbody tr:hover{background: rgba(255,255,255,.03)}
  .small{font-size:12px;color:var(--muted)}
  .badge{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    background: rgba(59,130,246,.14);
    border:1px solid rgba(59,130,246,.28);
    color: rgba(229,231,235,.95);
    font-size:12px;font-weight:800;
  }
  .tagpill{
    display:inline-flex;
    padding:4px 9px;
    border-radius:999px;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    color: rgba(229,231,235,.92);
    font-size:12px;
    margin: 2px 6px 0 0;
  }
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .filemeta{margin-top:6px;color:var(--muted);font-size:11px;word-break:break-all}
  .split{
    display:flex;gap:10px;align-items:center;flex-wrap:wrap
  }
  .rightTools{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
</style>
</head>

<body>
<script>
  // FORÇA WWW (evita sessão sumir por origem diferente)
  if (location.hostname === "colorglassfortaleza.com.br") {
    location.replace("https://www.colorglassfortaleza.com.br" + location.pathname + location.search + location.hash);
  }
</script>

<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <h1>ColorGlass • Upload + Tags</h1>
        <span>Storage + index por tags (Supabase)</span>
      </div>
    </div>

    <div class="pill">
      <span>Status:</span> <b id="authMini">Não logado</b>
    </div>
  </div>

  <div class="card">
    <div class="cardHead">
      <div class="title">
        <h2>Enviar arquivos + organizar com tags</h2>
        <p>Upload vai para o bucket <b>comprovantes</b>. Tags ficam na tabela <b>imagetags</b> usando <b>id = fullPath</b>.</p>
      </div>

      <div class="rightTools">
        <button id="login">Entrar com GitHub</button>
        <button id="logout" class="sec">Logout</button>
        <button id="reset" class="warn" type="button">RESET</button>
        <button id="listar" class="ghost" type="button">Listar</button>
      </div>
    </div>

    <div class="cardBody">
      <div class="row">
        <span class="badge">Upload</span>
        <span class="small" id="auth"></span>
      </div>

      <div class="row">
        <input type="file" id="file" accept="image/*,application/pdf">
        <button id="upload">Enviar</button>
      </div>

      <div class="row">
        <input type="text" id="tagsInput" placeholder="Tags (separe por vírgula): cozinha, bronze, 1036">
        <button id="salvarUltimo" class="good" type="button">Adicionar tags no ÚLTIMO upload</button>
      </div>

      <div class="hint">
        ✅ <b>Múltiplas tags</b>: este HTML adiciona tags sem apagar as antigas.<br>
        Se existir a função <b>RPC</b> <code>add_image_tag(p_id text, p_tag text)</code>, ela será usada automaticamente (melhor).
      </div>

      <div class="row" style="margin-top:14px">
        <span class="badge">Busca</span>
      </div>
      <div class="row">
        <input type="text" id="searchTag" placeholder="Buscar por 1 tag (ex: bronze)">
        <button id="buscar" type="button">Buscar</button>
        <button id="limparBusca" class="sec" type="button">Limpar</button>
      </div>

      <div id="listaWrap"></div>

      <p class="status" id="status"></p>
    </div>
  </div>
</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const SUPABASE_URL = "https://hfhwvzldhgqniqnurync.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_0j-jqB63odD2yvugj7olMA_s18OwuPl";

const supabase = createClient(
  SUPABASE_URL,
  SUPABASE_ANON_KEY,
  { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true } }
);

const BUCKET = "comprovantes";
const REDIRECT = "https://www.colorglassfortaleza.com.br/callback.html";
const TAGS_TABLE = "imagetags";
const RPC_ADD_TAG = "add_image_tag"; // se existir, usamos

const auth = document.getElementById("auth");
const authMini = document.getElementById("authMini");
const status = document.getElementById("status");
const listaWrap = document.getElementById("listaWrap");
const tagsInput = document.getElementById("tagsInput");
const salvarUltimoBtn = document.getElementById("salvarUltimo");
const searchTag = document.getElementById("searchTag");

let lastUploadedPath = null;

function safeName(n){
  return (n || "arquivo")
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g,"")
    .replace(/[^a-zA-Z0-9._-]/g,"_");
}
function setStatus(txt){ status.innerText = txt || ""; }
function append(txt){ status.innerText += (txt || "") + "\n"; }

function parseTags(str){
  // múltiplas tags
  const arr = (str || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean)
    .map(s => s.toLowerCase());
  // dedup
  return Array.from(new Set(arr));
}

function bytesToHuman(bytes){
  if (bytes == null) return "-";
  const units = ["B","KB","MB","GB"];
  let i = 0;
  let v = Number(bytes);
  while (v >= 1024 && i < units.length-1){ v /= 1024; i++; }
  return (i === 0 ? v : v.toFixed(2)) + " " + units[i];
}
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

async function refresh(){
  // deixa mais limpo (sem printar sessão gigante toda hora)
  try{
    const u = await supabase.auth.getUser();
    const user = u?.data?.user;
    if(user){
      const label = (user.email || user.user_metadata?.user_name || user.id);
      auth.innerText = "Logado: " + label;
      authMini.innerText = label;
    } else {
      auth.innerText = "Não logado";
      authMini.innerText = "Não logado";
    }
  } catch(e){
    auth.innerText = "Não logado (erro auth)";
    authMini.innerText = "Não logado";
  }
}

// ---------- STORAGE OPEN ----------
async function openObject(path){
  const signed = await supabase.storage.from(BUCKET).createSignedUrl(path, 600);
  if (!signed.error && signed.data?.signedUrl){
    window.open(signed.data.signedUrl, "_blank", "noopener");
    return;
  }
  const dl = await supabase.storage.from(BUCKET).download(path);
  if (dl.error){
    append("OPEN ERROR: " + dl.error.message);
    return;
  }
  const blobUrl = URL.createObjectURL(dl.data);
  window.open(blobUrl, "_blank", "noopener");
  setTimeout(() => URL.revokeObjectURL(blobUrl), 60_000);
}

// ---------- TAGS HELPERS ----------
async function getTagsForIds(ids){
  if(!ids.length) return new Map();
  const res = await supabase.from(TAGS_TABLE).select("id,tais").in("id", ids);
  const map = new Map();
  if(!res.error && Array.isArray(res.data)){
    for(const row of res.data){
      const t = row?.tais?.tags;
      map.set(row.id, Array.isArray(t) ? t : []);
    }
  }
  return map;
}

async function findIdsByTag(tag){
  const res = await supabase
    .from(TAGS_TABLE)
    .select("id")
    .contains("tais", { tags: [tag] })
    .limit(400);

  if(res.error) return [];
  return (res.data || []).map(r => r.id);
}

async function getExistingTags(id){
  const res = await supabase.from(TAGS_TABLE).select("id,tais").eq("id", id).maybeSingle();
  if(res.error) return [];
  const t = res.data?.tais?.tags;
  return Array.isArray(t) ? t : [];
}

// ✅ Melhor caminho: RPC para adicionar tag sem perder as antigas
async function addTagsAtomic(id, tagsArr){
  // tenta RPC. Se não existir, fallback pro merge no JS.
  // adiciona tags 1 por 1 para manter atômico.
  append("ADD TAGS -> " + id);
  append("TAGS INPUT -> " + JSON.stringify(tagsArr));

  // 1) tenta RPC
  let rpcOk = true;
  for(const t of tagsArr){
    const r = await supabase.rpc(RPC_ADD_TAG, { p_id: id, p_tag: t });
    if(r.error){
      rpcOk = false;
      append("RPC FAIL (vai fallback): " + r.error.message);
      break;
    }
  }
  if(rpcOk){
    append("RPC OK: tags adicionadas sem sobrescrever.");
    return { ok:true, mode:"rpc" };
  }

  // 2) fallback: merge no JS e upsert (funciona, mas não é tão forte quanto RPC)
  const oldTags = await getExistingTags(id);
  const merged = Array.from(new Set([...(oldTags||[]), ...(tagsArr||[])]));
  const payload = {
    id,
    tais: {
      tags: merged,
      updated_at: new Date().toISOString()
    }
  };

  const up = await supabase.from(TAGS_TABLE).upsert(payload, { onConflict: "id" }).select("id,tais");
  if(up.error){
    append("FALLBACK UPSERT ERROR: " + up.error.message);
    return { ok:false, mode:"fallback", error: up.error };
  }

  append("FALLBACK OK: tags mescladas e salvas.");
  return { ok:true, mode:"fallback" };
}

// ---------- LISTAGEM ----------
function renderTags(tags){
  if(!tags || !tags.length) return `<span class="small">(sem tags)</span>`;
  return tags.map(t => `<span class="tagpill">${escapeHtml(t)}</span>`).join("");
}

function renderTable(folder, files, tagsMap, filteredIdsSet=null){
  let html = `
    <div class="row" style="justify-content:space-between;margin-top:16px">
      <div class="split">
        <span class="badge">Pasta</span>
        <div><b>${escapeHtml(folder)}/</b></div>
      </div>
      <div class="small">${files.length} arquivo(s)</div>
    </div>

    <table>
      <thead>
        <tr>
          <th style="width:28%">Arquivo</th>
          <th style="width:10%">Tamanho</th>
          <th style="width:14%">Atualizado</th>
          <th style="width:12%">Tipo</th>
          <th style="width:26%">Tags</th>
          <th style="width:10%">Ações</th>
        </tr>
      </thead>
      <tbody>
  `;

  for(const f of files){
    const name = f.name;
    const size = bytesToHuman(f.metadata?.size ?? f.metadata?.contentLength ?? null);
    const updated = f.updated_at || f.created_at || "";
    const mime = f.metadata?.mimetype || f.metadata?.contentType || "-";
    const fullPath = `${folder}/${name}`;

    if(filteredIdsSet && !filteredIdsSet.has(fullPath)) continue;

    const tags = tagsMap.get(fullPath) || [];

    html += `
      <tr>
        <td>
          <b>${escapeHtml(name)}</b>
          <div class="filemeta">${escapeHtml(fullPath)}</div>
        </td>
        <td>${escapeHtml(size)}</td>
        <td>${escapeHtml(updated)}</td>
        <td>${escapeHtml(mime)}</td>

        <td>
          <div data-tags-view="${escapeHtml(fullPath)}">${renderTags(tags)}</div>
          <div class="row" style="margin-top:10px">
            <input type="text" data-tags-input="${escapeHtml(fullPath)}" placeholder="ex: cozinha, bronze, 1036" style="min-width:240px">
            <button type="button" class="good" data-add-tags="${escapeHtml(fullPath)}">Adicionar</button>
          </div>
        </td>

        <td class="actions">
          <button type="button" class="ghost" data-open="${escapeHtml(fullPath)}">Abrir</button>
        </td>
      </tr>
    `;
  }

  html += `</tbody></table>`;
  listaWrap.innerHTML = html;

  // abrir
  listaWrap.querySelectorAll("button[data-open]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const p = btn.getAttribute("data-open");
      append("OPEN: " + p);
      await openObject(p);
    });
  });

  // adicionar tags (sem sobrescrever)
  listaWrap.querySelectorAll("button[data-add-tags]").forEach(btn => {
    btn.addEventListener("click", async () => {
      const id = btn.getAttribute("data-add-tags");
      const inp = listaWrap.querySelector(`input[data-tags-input="${CSS.escape(id)}"]`);
      const tagsArr = parseTags(inp?.value || "");
      if(!tagsArr.length){
        append("ADD TAGS BLOQUEADO: sem tags.");
        return;
      }

      btn.disabled = true;
      try{
        append("ADD TAGS CLICK id=" + id);
        const result = await addTagsAtomic(id, tagsArr);
        if(!result.ok){
          append("ADD TAGS ERROR.");
          return;
        }

        // atualiza UI pegando do banco de novo
        const updatedTags = await getExistingTags(id);
        const view = listaWrap.querySelector(`div[data-tags-view="${CSS.escape(id)}"]`);
        if(view) view.innerHTML = renderTags(updatedTags);

        append("OK: tags atualizadas (" + result.mode + ").");
      } finally {
        btn.disabled = false;
      }
    });
  });
}

async function listMyFiles(filterByIds=null){
  await refresh();

  const u = await supabase.auth.getUser().catch(()=>({}));
  const user = u?.data?.user;
  if(!user){
    listaWrap.innerHTML = `<p class="small">Faça login para listar.</p>`;
    return;
  }

  const folder = user.id;
  append("LIST folder=" + folder);

  const res = await supabase.storage.from(BUCKET).list(folder, {
    limit: 200,
    offset: 0,
    sortBy: { column: "updated_at", order: "desc" }
  });

  if(res.error){
    listaWrap.innerHTML = `<p class="small" style="color:#ef4444">Erro ao listar: ${escapeHtml(res.error.message)}</p>`;
    return;
  }

  const files = res.data || [];
  if(!files.length){
    listaWrap.innerHTML = `<p class="small">Nenhum arquivo encontrado em <b>${escapeHtml(folder)}/</b>.</p>`;
    return;
  }

  const ids = files.map(f => `${folder}/${f.name}`);
  const tagsMap = await getTagsForIds(ids);

  const filteredIdsSet = filterByIds ? new Set(filterByIds) : null;
  renderTable(folder, files, tagsMap, filteredIdsSet);
}

// ---------- BOTÕES ----------
document.getElementById("login").onclick = async ()=>{
  setStatus("LOGIN...\n");
  const { error } = await supabase.auth.signInWithOAuth({
    provider: "github",
    options: { redirectTo: REDIRECT }
  });
  if(error){
    append("OAUTH ERROR: " + error.message);
    alert(error.message);
  } else {
    append("REDIRECTING...");
  }
};

document.getElementById("logout").onclick = async ()=>{
  await supabase.auth.signOut();
  listaWrap.innerHTML = "";
  setStatus("Logout OK.");
  await refresh();
};

document.getElementById("reset").onclick = async ()=>{
  setStatus("RESET...\n");
  try{ await supabase.auth.signOut(); } catch(e){}
  const keys = Object.keys(localStorage).filter(k => k.includes("sb-") || k.includes("supabase"));
  keys.forEach(k => localStorage.removeItem(k));
  append("REMOVIDAS KEYS:\n" + (keys.length ? keys.join("\n") : "(nenhuma)"));
  append("\nRELOAD...");
  location.reload();
};

document.getElementById("listar").onclick = async ()=>{ await listMyFiles(); };

// buscar por tag
document.getElementById("buscar").onclick = async ()=>{
  await refresh();
  const tag = (searchTag.value || "").trim().toLowerCase();
  if(!tag){
    append("BUSCA: digite uma tag.");
    return;
  }
  append("BUSCA TAG=" + tag);
  const ids = await findIdsByTag(tag);
  if(!ids.length){
    listaWrap.innerHTML = `<p class="small">Nenhum arquivo encontrado com a tag <b>${escapeHtml(tag)}</b>.</p>`;
    return;
  }
  await listMyFiles(ids);
};

document.getElementById("limpar").onclick = async ()=>{
  searchTag.value = "";
  await listMyFiles();
};

// adicionar tags no último upload (sem apagar as antigas)
salvarUltimoBtn.onclick = async ()=>{
  await refresh();
  if(!lastUploadedPath){
    append("Nenhum upload recente.");
    return;
  }
  const tagsArr = parseTags(tagsInput.value);
  if(!tagsArr.length){
    append("Sem tags para adicionar.");
    return;
  }
  salvarUltimoBtn.disabled = true;
  try{
    append("ADD TAGS LAST path=" + lastUploadedPath);
    const result = await addTagsAtomic(lastUploadedPath, tagsArr);
    if(result.ok){
      append("OK: tags adicionadas no último upload (" + result.mode + ").");
      await listMyFiles();
    }
  } finally {
    salvarUltimoBtn.disabled = false;
  }
};

// ---------- UPLOAD (MANTIDO) ----------
document.getElementById("upload").onclick = async ()=>{
  // MANTIDO: você pediu para não mexer no upload do storage.
  await refresh();

  const u = await supabase.auth.getUser().catch(()=>({}));
  const user = u?.data?.user;

  if(!user){
    append("UPLOAD BLOQUEADO: não logado.");
    return;
  }

  const file = document.getElementById("file").files[0];
  if(!file){
    append("UPLOAD BLOQUEADO: selecione um arquivo.");
    return;
  }

  const path = user.id + "/" + crypto.randomUUID() + "_" + safeName(file.name);
  append("UPLOAD START");
  append("PATH=" + path);

  const up = await supabase.storage.from(BUCKET).upload(path, file);
  append("UPLOAD RESULT:");
  append(JSON.stringify(up, null, 2));
  append("");

  if(up.error){
    append("UPLOAD ERROR: " + up.error.message);
    return;
  }

  const signed = await supabase.storage.from(BUCKET).createSignedUrl(path, 600);
  append("SIGNED RESULT:");
  append(JSON.stringify(signed, null, 2));
  append("");

  if(signed.error){
    append("SIGNED ERROR: " + signed.error.message);
    return;
  }

  append("SIGNED URL OK");

  lastUploadedPath = path;
  append("LAST UPLOAD SET: " + lastUploadedPath);

  // opcional: auto adicionar tags do input ao terminar upload (sem apagar)
  // const tagsArr = parseTags(tagsInput.value);
  // if(tagsArr.length){
  //   await addTagsAtomic(lastUploadedPath, tagsArr);
  //   append("AUTO TAGS OK");
  // }
};

await refresh();
supabase.auth.onAuthStateChange(async () => {
  await refresh();
});
</script>
</body>
</html>












