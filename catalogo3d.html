<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CatÃ¡logo 3D</title>

  <!-- âœ… IMPORTMAP (mantÃ©m seu setup que funciona) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    #ui {
      width: 320px;
      padding: 15px;
      background: #1c1c1c;
      box-sizing: border-box;
      overflow: auto;
    }

    label { display:block; margin-top:10px; font-size:14px; }

    input, select, button {
      width:100%;
      margin-top:5px;
      padding:8px;
      font-size:14px;
      box-sizing:border-box;
    }

    button {
      margin-top: 10px;
      cursor: pointer;
      background: #2a2a2a;
      color: #fff;
      border: none;
    }
    button:hover { background:#444; }

    #canvas-container { flex:1; position:relative; }

    #status {
      margin-top: 12px;
      padding: 10px;
      background: #141414;
      font-size: 12px;
      line-height: 1.5;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .swatch {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid #333;
      flex: 0 0 auto;
    }

    /* âœ… Suas cores (classes) */
    .cor.preto { background:#000; }
    .cor.prata { background:#c6c7c9; }
    .cor.bronze1001 { background:#716859; }
    .cor.dourado { background:#B89C5D; }
    .cor.inox { background:#918B82; }

    .muted { color:#bdbdbd; }
    .ok { color:#7CFC90; }
    .warn { color:#FFD27C; }
    .err { color:#FF7C7C; }
  </style>
</head>

<body>
  <div id="ui">
    <h3 style="margin:0 0 10px 0;">CatÃ¡logo 3D</h3>

    <label>Modelo</label>
    <select id="modeloSelect"></select>

    <label>Cor</label>
    <div class="row" style="margin-top:6px;">
      <div id="corSwatch" class="swatch cor prata" title="preview"></div>
      <select id="corSelect"></select>
    </div>

    <button id="resetCamera">Resetar cÃ¢mera</button>

    <div id="status">ðŸš€ Iniciando app...</div>
  </div>

  <div id="canvas-container"></div>

  <script type="module">
    const statusEl = document.getElementById("status");
    function log(msg) {
      statusEl.textContent = msg;
      console.log(msg);
    }

    // ===== Imports
    const THREE = await import("three");
    const { GLTFLoader } = await import("three/addons/loaders/GLTFLoader.js");

    // ===== Base dir (mantÃ©m robusto)
    function computeBaseDir() {
      const path = window.location.pathname;
      if (path.endsWith("/")) return path;
      return path.slice(0, path.lastIndexOf("/") + 1);
    }
    const BASE_DIR = computeBaseDir();

    function makeUrlCandidates(filename) {
      return [
        filename,
        "./" + filename,
        BASE_DIR + filename,
        "/" + filename,
        BASE_DIR + "assets/" + filename,
        "/assets/" + filename,
        BASE_DIR + "models/" + filename,
        "/models/" + filename,
      ];
    }

    // ===== UI modelos
    const modelos = [
      { label: "Perfil 1036", filename: "1036.glb" },
    ].map(m => ({ label: m.label, urls: makeUrlCandidates(m.filename) }));

    const modeloSelect = document.getElementById("modeloSelect");
    modelos.forEach(m => {
      const opt = document.createElement("option");
      opt.value = m.label;
      opt.textContent = m.label;
      modeloSelect.appendChild(opt);
    });

    // ===== UI cores (suas classes)
    const cores = [
      { key: "preto", label: "Preto", hex: "#000000" },
      { key: "prata", label: "Prata", hex: "#c6c7c9" },
      { key: "bronze1001", label: "Bronze 1001", hex: "#716859" },
      { key: "dourado", label: "Dourado", hex: "#B89C5D" },
      { key: "inox", label: "Inox", hex: "#918B82" },
    ];

    const corSelect = document.getElementById("corSelect");
    const corSwatch = document.getElementById("corSwatch");

    cores.forEach(c => {
      const opt = document.createElement("option");
      opt.value = c.key;
      opt.textContent = c.label;
      corSelect.appendChild(opt);
    });

    function updateSwatch(key) {
      corSwatch.className = "swatch cor " + key;
    }

    // ===== Three setup
    const container = document.getElementById("canvas-container");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      60,
      container.clientWidth / container.clientHeight,
      0.1,
      100000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    // âœ… Melhor visibilidade
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;

    container.appendChild(renderer.domElement);

    // ===== IluminaÃ§Ã£o melhor (sem depender de HDRI)
    const ambient = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambient);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x202020, 0.65);
    scene.add(hemi);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.1);
    keyLight.position.set(8, 12, 8);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.55);
    fillLight.position.set(-10, 6, -6);
    scene.add(fillLight);

    // chÃ£o â€œinvisÃ­velâ€ pra dar referÃªncia
    const grid = new THREE.GridHelper(500, 50);
    grid.material.opacity = 0.12;
    grid.material.transparent = true;
    scene.add(grid);

    const axes = new THREE.AxesHelper(120);
    axes.material.opacity = 0.25;
    axes.material.transparent = true;
    scene.add(axes);

    // ===== Loader
    const loader = new GLTFLoader();
    let currentModel = null;

    // ===== Camera controls (volta pro â€œde antesâ€: raio 400 e sem mexer com distÃ¢ncia automÃ¡tica agressiva)
    const cameraState = {
      isDragging: false,
      lastX: 0,
      lastY: 0,
      yaw: Math.PI / 4,
      pitch: Math.PI / 7,
      radius: 400
    };

    function atualizarCamera() {
      const maxPitch = Math.PI / 2 - 0.05;
      const minPitch = -maxPitch;
      cameraState.pitch = Math.max(minPitch, Math.min(maxPitch, cameraState.pitch));

      const x = cameraState.radius * Math.cos(cameraState.pitch) * Math.cos(cameraState.yaw);
      const y = cameraState.radius * Math.sin(cameraState.pitch);
      const z = cameraState.radius * Math.cos(cameraState.pitch) * Math.sin(cameraState.yaw);

      camera.position.set(x, y, z);
      camera.lookAt(0, 0, 0);
    }

    renderer.domElement.addEventListener("mousedown", (event) => {
      cameraState.isDragging = true;
      cameraState.lastX = event.clientX;
      cameraState.lastY = event.clientY;
    });

    window.addEventListener("mouseup", () => {
      cameraState.isDragging = false;
    });

    window.addEventListener("mousemove", (event) => {
      if (!cameraState.isDragging) return;

      const deltaX = event.clientX - cameraState.lastX;
      const deltaY = event.clientY - cameraState.lastY;

      cameraState.lastX = event.clientX;
      cameraState.lastY = event.clientY;

      const sensitivity = 0.005;
      cameraState.yaw += deltaX * sensitivity;
      cameraState.pitch += deltaY * sensitivity;

      atualizarCamera();
    });

    renderer.domElement.addEventListener("wheel", (event) => {
      event.preventDefault();
      const zoomFactor = 1 + event.deltaY * 0.001;
      cameraState.radius = Math.max(30, Math.min(5000, cameraState.radius * zoomFactor));
      atualizarCamera();
    }, { passive: false });

    document.getElementById("resetCamera").addEventListener("click", () => {
      cameraState.yaw = Math.PI / 4;
      cameraState.pitch = Math.PI / 7;
      cameraState.radius = 400;
      atualizarCamera();
      log("ðŸŽ¥ CÃ¢mera resetada.");
    });

    window.addEventListener("resize", () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    // ===== Helpers
    function limparModelo() {
      if (!currentModel) return;
      scene.remove(currentModel);
      currentModel.traverse((node) => {
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) node.material.forEach((m) => m.dispose());
          else node.material.dispose();
        }
      });
      currentModel = null;
    }

    function centralizarModelo(model) {
      // centraliza no 0,0,0 (nÃ£o mexe no raio da cÃ¢mera)
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);

      // dica visual no log
      const size = box.getSize(new THREE.Vector3());
      log(`âœ… Modelo centralizado. Size: x=${size.x.toFixed(3)} y=${size.y.toFixed(3)} z=${size.z.toFixed(3)}`);
    }

    function aplicarCorNoModelo(hex) {
      if (!currentModel) return;

      const color = new THREE.Color(hex);

      currentModel.traverse((node) => {
        if (!node.isMesh) return;

        // garante que pega material "separado" (sem contaminar cache)
        const mats = Array.isArray(node.material) ? node.material : [node.material];

        mats.forEach((mat) => {
          if (!mat) return;

          // muitos GLBs usam MeshStandardMaterial (PBR)
          if ("color" in mat) mat.color = color;

          // pra ficar com â€œcaraâ€ de alumÃ­nio/metal
          if ("metalness" in mat) mat.metalness = 0.75;
          if ("roughness" in mat) mat.roughness = 0.35;

          // se tiver textura, nÃ£o some
          mat.needsUpdate = true;
        });
      });

      log(`ðŸŽ¨ Cor aplicada: ${hex}`);
    }

    async function pickFirstOkUrl(urls) {
      for (const u of urls) {
        const abs = new URL(u, window.location.href).toString();
        try {
          const r = await fetch(abs, { cache: "no-store" });
          if (r.ok) return u;
        } catch {}
      }
      return null;
    }

    async function carregarModelo(modelo) {
      limparModelo();
      log("â³ Carregando modelo...");

      const urlOk = await pickFirstOkUrl(modelo.urls);
      if (!urlOk) {
        log("âŒ Nenhuma URL do modelo respondeu 200. Caminho/hosting errado.");
        return;
      }

      loader.load(
        urlOk,
        (gltf) => {
          currentModel = gltf.scene;
          scene.add(currentModel);

          centralizarModelo(currentModel);

          // aplica cor atual do dropdown
          const selected = cores.find(c => c.key === corSelect.value) || cores[0];
          aplicarCorNoModelo(selected.hex);

          log(`âœ… Modelo carregado: ${modelo.label} (${urlOk})`);
        },
        undefined,
        (err) => {
          console.error(err);
          log("âŒ Erro ao carregar GLB (veja console).");
        }
      );
    }

    // ===== Eventos UI
    modeloSelect.addEventListener("change", async (e) => {
      const modelo = modelos.find(m => m.label === e.target.value) || modelos[0];
      await carregarModelo(modelo);
    });

    corSelect.addEventListener("change", () => {
      const c = cores.find(x => x.key === corSelect.value) || cores[0];
      updateSwatch(c.key);
      aplicarCorNoModelo(c.hex);
    });

    // ===== Loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // ===== Start
    modeloSelect.value = modelos[0].label;
    corSelect.value = "prata";
    updateSwatch("prata");

    atualizarCamera();
    animate();
    await carregarModelo(modelos[0]);
  </script>
</body>
</html>




