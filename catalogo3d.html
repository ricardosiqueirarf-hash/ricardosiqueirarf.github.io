<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CatÃ¡logo 3D (Cores + Debug)</title>

  <!-- âœ… IMPORTMAP: resolve "three" e "three/addons/" no browser -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #ui {
      width: 340px;
      padding: 15px;
      background: #1c1c1c;
      box-sizing: border-box;
      overflow: auto;
    }
    label { display:block; margin-top:10px; font-size:14px; }
    select, button {
      width:100%;
      margin-top:5px;
      padding:8px;
      font-size:14px;
      box-sizing:border-box;
    }
    button {
      margin-top: 10px;
      cursor: pointer;
      background: #2a2a2a;
      color: #fff;
      border: none;
    }
    button:hover { background:#444; }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }
    .swatch {
      width: 26px;
      height: 26px;
      border-radius: 6px;
      border: 1px solid #333;
      flex: 0 0 auto;
    }

    #canvas-container { flex:1; position:relative; }

    #status {
      margin-top: 12px;
      padding: 10px;
      background: #141414;
      font-size: 12px;
      line-height: 1.5;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .ok { color:#7CFC90; }
    .warn { color:#FFD27C; }
    .err { color:#FF7C7C; }
    .muted { color:#bdbdbd; }
    hr { border: none; border-top:1px solid #333; margin: 12px 0; }
  </style>
</head>

<body>
  <div id="ui">
    <h3 style="margin:0 0 10px 0;">CatÃ¡logo 3D <span class="muted">(Cores)</span></h3>

    <label>Modelo</label>
    <select id="modeloSelect"></select>

    <label>Cor do Perfil</label>
    <div class="row">
      <div id="corSwatch" class="swatch" title="Preview da cor"></div>
      <select id="corSelect" style="flex:1;"></select>
    </div>

    <button id="resetCamera">Resetar cÃ¢mera</button>
    <button id="btnTestGLB">Testar GLB (fetch)</button>

    <hr />

    <div id="status">ðŸš€ Iniciando app...</div>
  </div>

  <div id="canvas-container"></div>

  <script type="module">
    // =========================
    // DEBUG HELPERS
    // =========================
    const statusEl = document.getElementById("status");
    function logLine(msg, cls="muted") {
      const line = document.createElement("div");
      line.className = cls;
      line.textContent = msg;
      statusEl.appendChild(line);
      statusEl.scrollTop = statusEl.scrollHeight;
      console.log(msg);
    }
    function setStatusHeader(msg) {
      statusEl.textContent = msg + "\n";
      console.log(msg);
    }

    // =========================
    // BASE PATH (GitHub Pages safe)
    // =========================
    function computeBaseDir() {
      const path = window.location.pathname;
      if (path.endsWith("/")) return path;
      const lastSlash = path.lastIndexOf("/");
      return path.slice(0, lastSlash + 1);
    }
    const BASE_DIR = computeBaseDir();
    const ORIGIN = window.location.origin;
    const FULL_BASE = ORIGIN + BASE_DIR;

    setStatusHeader("ðŸš€ Iniciando app...");
    logLine(`â„¹ï¸ origin: ${ORIGIN}`, "muted");
    logLine(`â„¹ï¸ pathname: ${window.location.pathname}`, "muted");
    logLine(`â„¹ï¸ BASE_DIR detectado: ${BASE_DIR}`, "muted");
    logLine(`â„¹ï¸ FULL_BASE: ${FULL_BASE}`, "muted");

    // =========================
    // IMPORTS
    // =========================
    let THREE, GLTFLoader;
    try {
      logLine(`ðŸ”§ Importando Three: "three"`, "muted");
      THREE = await import("three");

      logLine(`ðŸ”§ Importando GLTFLoader: "three/addons/loaders/GLTFLoader.js"`, "muted");
      ({ GLTFLoader } = await import("three/addons/loaders/GLTFLoader.js"));

      logLine("âœ… DependÃªncias importadas com sucesso.", "ok");
      logLine(`â„¹ï¸ THREE.REVISION: ${THREE.REVISION}`, "muted");
    } catch (e) {
      logLine("âŒ Falha importando dependÃªncias.", "err");
      logLine(String(e?.message || e), "err");
      throw e;
    }

    // =========================
    // THREE SETUP
    // =========================
    const container = document.getElementById("canvas-container");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      60,
      container.clientWidth / container.clientHeight,
      0.1,
      100000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    container.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);

    const directional = new THREE.DirectionalLight(0xffffff, 0.9);
    directional.position.set(10, 20, 10);
    scene.add(directional);

    // referÃªncia visual
    const grid = new THREE.GridHelper(500, 50);
    grid.material.opacity = 0.15;
    grid.material.transparent = true;
    scene.add(grid);

    const axes = new THREE.AxesHelper(200);
    axes.material.opacity = 0.35;
    axes.material.transparent = true;
    scene.add(axes);

    // =========================
    // LOADING MANAGER (DEBUG)
    // =========================
    const manager = new THREE.LoadingManager();
    manager.onStart = (url, itemsLoaded, itemsTotal) => {
      logLine(`ðŸ“¦ Manager start: ${url} (${itemsLoaded}/${itemsTotal})`, "muted");
    };
    manager.onProgress = (url, itemsLoaded, itemsTotal) => {
      logLine(`â¬‡ï¸ Manager progress: ${url} (${itemsLoaded}/${itemsTotal})`, "muted");
    };
    manager.onLoad = () => {
      logLine("âœ… Manager load: terminou tudo", "ok");
    };
    manager.onError = (url) => {
      logLine(`âŒ Manager error em: ${url}`, "err");
    };

    const loader = new GLTFLoader(manager);

    let currentModel = null;

    // =========================
    // CORES (do seu CSS -> HEX)
    // =========================
    const CORES = [
      { key: "preto",      label: "Preto",       hex: "#000000" },
      { key: "prata",      label: "Prata",       hex: "#c6c7c9" },
      { key: "bronze1001", label: "Bronze 1001", hex: "#716859" },
      { key: "dourado",    label: "Dourado",     hex: "#B89C5D" },
      { key: "inox",       label: "Inox",        hex: "#918B82" }
    ];

    const corSelect = document.getElementById("corSelect");
    const corSwatch = document.getElementById("corSwatch");

    CORES.forEach(c => {
      const opt = document.createElement("option");
      opt.value = c.key;
      opt.textContent = c.label;
      corSelect.appendChild(opt);
    });

    function getCorAtualHex() {
      const key = corSelect.value;
      const cor = CORES.find(c => c.key === key) || CORES[0];
      return cor.hex;
    }

    function atualizarSwatch() {
      const hex = getCorAtualHex();
      corSwatch.style.background = hex;
      corSwatch.title = hex;
    }

    // =========================
    // MODELOS + URLS
    // =========================
    function makeUrlCandidates(filename) {
      return [
        filename,
        "./" + filename,
        BASE_DIR + filename,
        "/" + filename,
        BASE_DIR + "assets/" + filename,
        "/assets/" + filename,
        BASE_DIR + "models/" + filename,
        "/models/" + filename
      ];
    }

    const modelos = [
      { label: "Perfil 1036", filename: "1036.glb" }
    ].map(m => ({
      label: m.label,
      urls: makeUrlCandidates(m.filename)
    }));

    const modeloSelect = document.getElementById("modeloSelect");
    modelos.forEach((modelo) => {
      const option = document.createElement("option");
      option.value = modelo.label;
      option.textContent = modelo.label;
      modeloSelect.appendChild(option);
    });

    // =========================
    // UTILS
    // =========================
    function limparModelo() {
      if (!currentModel) return;
      scene.remove(currentModel);
      currentModel.traverse((node) => {
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) node.material.forEach((m) => m.dispose());
          else node.material.dispose();
        }
      });
      currentModel = null;
      logLine("ðŸ§¹ Modelo anterior removido e recursos liberados.", "muted");
    }

    function centralizarModelo(model) {
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);

      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);

      // âš ï¸ Se o modelo for MUITO pequeno (tipo 0.05), a cÃ¢mera fica colada e some fÃ¡cil.
      // EntÃ£o a gente forÃ§a um mÃ­nimo decente.
      const distance = Math.max(maxDim * 2.2, 2.0);

      cameraState.radius = distance;
      cameraState.yaw = Math.PI / 4;
      cameraState.pitch = Math.PI / 7;
      atualizarCamera();

      logLine(`ðŸ“ BoundingBox size: x=${size.x.toFixed(4)} y=${size.y.toFixed(4)} z=${size.z.toFixed(4)}`, "muted");
      logLine(`ðŸŽ¯ Camera distance: ${distance.toFixed(3)}`, "muted");
    }

    async function testFetch(url) {
      try {
        const abs = new URL(url, window.location.href).toString();
        logLine(`ðŸ§ª Fetch test: ${url}  ->  ${abs}`, "muted");
        const r = await fetch(abs, { cache: "no-store" });
        logLine(`   â†³ status: ${r.status} ${r.statusText}`, r.ok ? "ok" : "err");
        const buf = await r.arrayBuffer();
        logLine(`   â†³ bytes: ${buf.byteLength}`, r.ok ? "ok" : "err");
        return r.ok;
      } catch (e) {
        logLine(`   â†³ fetch falhou: ${String(e?.message || e)}`, "err");
        return false;
      }
    }

    // =========================
    // APLICAR COR NO MODELO (tint)
    // =========================
    function aplicarCorNoModelo(model, hex) {
      if (!model) return;

      const tint = new THREE.Color(hex);
      let count = 0;

      model.traverse((node) => {
        if (!node.isMesh) return;

        const applyToMat = (mat) => {
          if (!mat) return;
          // Se tem propriedade "color", dÃ¡ pra tingir
          if (mat.color) {
            mat.color.copy(tint);
            mat.needsUpdate = true;
            count++;
          }
        };

        if (Array.isArray(node.material)) node.material.forEach(applyToMat);
        else applyToMat(node.material);
      });

      logLine(`ðŸŽ¨ Cor aplicada (${hex}) em ${count} material(is).`, count ? "ok" : "warn");
    }

    // =========================
    // LOAD COM FALLBACK
    // =========================
    async function carregarModeloComFallback(urls, label) {
      if (!urls || urls.length === 0) {
        logLine("âŒ Nenhuma URL configurada para o modelo.", "err");
        return;
      }

      limparModelo();

      logLine(`ðŸ”Ž Testando URLs do modelo: ${label}`, "muted");
      let firstGood = null;

      for (const u of urls) {
        const ok = await testFetch(u);
        if (ok && !firstGood) firstGood = u;
      }

      if (!firstGood) {
        logLine("âŒ Nenhuma URL respondeu OK no fetch. EntÃ£o Ã© caminho/hosting.", "err");
        return;
      }

      logLine(`âœ… Vou carregar pelo primeiro OK: ${firstGood}`, "ok");
      logLine(`â³ loader.load(${firstGood})`, "muted");

      loader.load(
        firstGood,
        (gltf) => {
          currentModel = gltf.scene;
          scene.add(currentModel);

          centralizarModelo(currentModel);

          // aplica a cor selecionada assim que carregar
          aplicarCorNoModelo(currentModel, getCorAtualHex());

          logLine(`âœ… Modelo carregado: ${label}`, "ok");
          logLine(`â„¹ï¸ Scene children: ${scene.children.length}`, "muted");
        },
        (xhr) => {
          if (!xhr || !xhr.total) {
            logLine("â¬‡ï¸ Progresso: carregando (sem total disponÃ­vel)...", "muted");
            return;
          }
          const pct = (xhr.loaded / xhr.total) * 100;
          logLine(`â¬‡ï¸ Progresso: ${pct.toFixed(1)}% (${xhr.loaded}/${xhr.total})`, "muted");
        },
        (err) => {
          logLine("âŒ Erro ao carregar GLB no loader.load().", "err");
          logLine(String(err?.message || err), "err");
          console.error(err);
        }
      );
    }

    // =========================
    // CAMERA CONTROLS (fix: impedir sumir)
    // =========================
    const cameraState = {
      isDragging: false,
      lastX: 0,
      lastY: 0,
      yaw: Math.PI / 4,
      pitch: Math.PI / 7,
      radius: 4
    };

    function atualizarCamera() {
      const maxPitch = Math.PI / 2 - 0.05;
      const minPitch = -maxPitch;
      cameraState.pitch = Math.max(minPitch, Math.min(maxPitch, cameraState.pitch));

      // ðŸ”’ clamp radius (evita atravessar o objeto e â€œsumirâ€)
      cameraState.radius = Math.max(0.5, Math.min(5000, cameraState.radius));

      const x = cameraState.radius * Math.cos(cameraState.pitch) * Math.cos(cameraState.yaw);
      const y = cameraState.radius * Math.sin(cameraState.pitch);
      const z = cameraState.radius * Math.cos(cameraState.pitch) * Math.sin(cameraState.yaw);

      camera.position.set(x, y, z);
      camera.lookAt(0, 0, 0);

      // Near/Far adaptativo (evita clip quando modelo Ã© pequeno)
      camera.near = Math.max(0.001, cameraState.radius / 2000);
      camera.far  = Math.max(1000,  cameraState.radius * 2000);
      camera.updateProjectionMatrix();
    }

    renderer.domElement.addEventListener("mousedown", (event) => {
      cameraState.isDragging = true;
      cameraState.lastX = event.clientX;
      cameraState.lastY = event.clientY;
    });

    window.addEventListener("mouseup", () => {
      cameraState.isDragging = false;
    });

    window.addEventListener("mousemove", (event) => {
      if (!cameraState.isDragging) return;

      const deltaX = event.clientX - cameraState.lastX;
      const deltaY = event.clientY - cameraState.lastY;

      cameraState.lastX = event.clientX;
      cameraState.lastY = event.clientY;

      const sensitivity = 0.005;
      cameraState.yaw += deltaX * sensitivity;
      cameraState.pitch += deltaY * sensitivity;

      atualizarCamera();
    });

    renderer.domElement.addEventListener("wheel", (event) => {
      event.preventDefault();
      const zoomFactor = 1 + event.deltaY * 0.001;
      cameraState.radius = cameraState.radius * zoomFactor;
      atualizarCamera();
    }, { passive: false });

    document.getElementById("resetCamera").addEventListener("click", () => {
      cameraState.yaw = Math.PI / 4;
      cameraState.pitch = Math.PI / 7;
      // um valor seguro
      cameraState.radius = Math.max(cameraState.radius, 2.0);
      atualizarCamera();
      logLine("ðŸŽ¥ CÃ¢mera resetada.", "ok");
    });

    window.addEventListener("resize", () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
      logLine("ðŸ“ Resize OK.", "muted");
    });

    // =========================
    // UI EVENTS
    // =========================
    modeloSelect.addEventListener("change", async (event) => {
      const modelo = modelos.find((item) => item.label === event.target.value);
      if (!modelo) return;
      await carregarModeloComFallback(modelo.urls, modelo.label);
    });

    document.getElementById("btnTestGLB").addEventListener("click", async () => {
      const modelo = modelos.find((m) => m.label === modeloSelect.value) || modelos[0];
      logLine("ðŸ§ª Rodando teste manual de fetch nas URLs do modelo...", "warn");
      for (const u of modelo.urls) await testFetch(u);
      logLine("ðŸ§ª Teste finalizado.", "warn");
    });

    // âœ… muda a cor em tempo real
    corSelect.addEventListener("change", () => {
      atualizarSwatch();
      const hex = getCorAtualHex();
      aplicarCorNoModelo(currentModel, hex);
    });

    // =========================
    // RENDER LOOP
    // =========================
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Start
    atualizarSwatch();
    atualizarCamera();
    animate();

    modeloSelect.value = modelos[0].label;
    corSelect.value = CORES[0].key;

    await carregarModeloComFallback(modelos[0].urls, modelos[0].label);
  </script>
</body>
</html>




