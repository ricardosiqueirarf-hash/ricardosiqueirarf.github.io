<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cat√°logo 3D (Debug PRO)</title>

  <!-- ‚úÖ IMPORTMAP: resolve "three" e "three/addons/" no browser -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #ui {
      width: 340px;
      padding: 15px;
      background: #1c1c1c;
      box-sizing: border-box;
      overflow: auto;
    }
    label { display:block; margin-top:10px; font-size:14px; }
    input, select, button {
      width:100%;
      margin-top:5px;
      padding:8px;
      font-size:14px;
      box-sizing:border-box;
    }
    button {
      margin-top: 10px;
      cursor: pointer;
      background: #2a2a2a;
      color: #fff;
      border: none;
      border-radius: 8px;
    }
    button:hover { background:#444; }
    #canvas-container { flex:1; position:relative; }
    #status {
      margin-top: 12px;
      padding: 10px;
      background: #141414;
      font-size: 12px;
      line-height: 1.5;
      border-radius: 10px;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 55vh;
      overflow: auto;
    }
    .ok { color:#7CFC90; }
    .warn { color:#FFD27C; }
    .err { color:#FF7C7C; }
    .muted { color:#bdbdbd; }
    hr { border: none; border-top:1px solid #333; margin: 12px 0; }
    .row { display:flex; gap:10px; }
    .row > * { flex:1; }

    /* preview simples das cores no select (texto) */
    .hint {
      font-size: 12px;
      margin-top: 6px;
      color: #bdbdbd;
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div id="ui">
    <h3 style="margin:0 0 10px 0;">Cat√°logo 3D <span class="muted">(Debug PRO)</span></h3>

    <label>Modelo</label>
    <select id="modeloSelect"></select>

    <label>Cor do perfil</label>
    <select id="corSelect"></select>
    <div class="hint">Dica: isso recolore o material do modelo (baseColor). Se o GLB tiver textura, a cor pode ‚Äúmisturar‚Äù.</div>

    <div class="row">
      <button id="resetCamera">Resetar c√¢mera</button>
      <button id="btnFrame">Enquadrar</button>
    </div>

    <div class="row">
      <button id="btnTestGLB">Testar GLB (fetch)</button>
      <button id="btnToggleWire">Wireframe</button>
    </div>

    <div class="row">
      <button id="btnToggleBox">BoxHelper</button>
      <button id="btnToggleGrid">Grid</button>
    </div>

    <hr />

    <div id="status">üöÄ Iniciando app...</div>
  </div>

  <div id="canvas-container"></div>

  <script type="module">
    // =========================
    // DEBUG HELPERS
    // =========================
    const statusEl = document.getElementById("status");
    function logLine(msg, cls="muted") {
      const line = document.createElement("div");
      line.className = cls;
      line.textContent = msg;
      statusEl.appendChild(line);
      statusEl.scrollTop = statusEl.scrollHeight;
      console.log(msg);
    }
    function setStatusHeader(msg) {
      statusEl.textContent = msg + "\n";
      console.log(msg);
    }

    // =========================
    // BASE PATH
    // =========================
    function computeBaseDir() {
      const path = window.location.pathname;
      if (path.endsWith("/")) return path;
      const lastSlash = path.lastIndexOf("/");
      return path.slice(0, lastSlash + 1);
    }
    const BASE_DIR = computeBaseDir();
    const ORIGIN = window.location.origin;
    const FULL_BASE = ORIGIN + BASE_DIR;

    setStatusHeader("üöÄ Iniciando app...");
    logLine(`‚ÑπÔ∏è origin: ${ORIGIN}`, "muted");
    logLine(`‚ÑπÔ∏è pathname: ${window.location.pathname}`, "muted");
    logLine(`‚ÑπÔ∏è BASE_DIR detectado: ${BASE_DIR}`, "muted");
    logLine(`‚ÑπÔ∏è FULL_BASE: ${FULL_BASE}`, "muted");

    // =========================
    // IMPORTS
    // =========================
    let THREE, GLTFLoader;
    try {
      logLine(`üîß Importando Three: "three"`, "muted");
      THREE = await import("three");

      logLine(`üîß Importando GLTFLoader: "three/addons/loaders/GLTFLoader.js"`, "muted");
      ({ GLTFLoader } = await import("three/addons/loaders/GLTFLoader.js"));

      logLine("‚úÖ Depend√™ncias importadas com sucesso.", "ok");
      logLine(`‚ÑπÔ∏è THREE.REVISION: ${THREE.REVISION}`, "muted");
    } catch (e) {
      logLine("‚ùå Falha importando depend√™ncias.", "err");
      logLine(String(e?.message || e), "err");
      throw e;
    }

    // =========================
    // THREE SETUP
    // =========================
    const container = document.getElementById("canvas-container");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      60,
      container.clientWidth / container.clientHeight,
      0.001,
      1000000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    container.appendChild(renderer.domElement);

    // =========================
    // LIGHTS (MELHORADAS / MAIS FORTES)
    // =========================
    // Ambiente bem mais forte pra n√£o ficar escuro
    const ambientLight = new THREE.AmbientLight(0xffffff, 2.2);
    scene.add(ambientLight);

    // Direcional principal bem mais forte
    const dir = new THREE.DirectionalLight(0xffffff, 3.5);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // Fill lights (luz de preenchimento) pra acabar com sombras duras
    const dirFill1 = new THREE.DirectionalLight(0xffffff, 2.2);
    dirFill1.position.set(-18, 12, 6);
    scene.add(dirFill1);

    const dirFill2 = new THREE.DirectionalLight(0xffffff, 1.8);
    dirFill2.position.set(6, 10, -18);
    scene.add(dirFill2);

    // Hemisf√©rica ajuda MUITO em modelos met√°licos/escuros
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.6);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);

    // =========================
    // Helpers
    // =========================
    const grid = new THREE.GridHelper(10, 20);
    grid.material.opacity = 0.20;
    grid.material.transparent = true;
    scene.add(grid);

    const axes = new THREE.AxesHelper(2);
    axes.material.opacity = 0.45;
    axes.material.transparent = true;
    scene.add(axes);

    let boxHelper = null;
    let wireframeEnabled = false;
    let gridEnabled = true;
    let boxEnabled = true;

    // =========================
    // LOADING MANAGER (DEBUG)
    // =========================
    const manager = new THREE.LoadingManager();
    manager.onStart = (url, itemsLoaded, itemsTotal) => {
      logLine(`üì¶ Manager start: ${url} (${itemsLoaded}/${itemsTotal})`, "muted");
    };
    manager.onProgress = (url, itemsLoaded, itemsTotal) => {
      logLine(`‚¨áÔ∏è Manager progress: ${url} (${itemsLoaded}/${itemsTotal})`, "muted");
    };
    manager.onLoad = () => logLine("‚úÖ Manager load: terminou tudo", "ok");
    manager.onError = (url) => logLine(`‚ùå Manager error em: ${url}`, "err");

    const loader = new GLTFLoader(manager);

    // =========================
    // MODELOS
    // =========================
    function makeUrlCandidates(filename) {
      return [
        filename,
        "./" + filename,
        BASE_DIR + filename,
        "/" + filename,
        BASE_DIR + "assets/" + filename,
        "/assets/" + filename,
        BASE_DIR + "models/" + filename,
        "/models/" + filename,
      ];
    }

    const modelos = [
      { label: "Perfil 1036", filename: "1036.glb" },
      { label: "Perfil Slim", filename: "3545.glb" },
      { label: "Perfil Invis√≠vel", filename: "3446.glb" },
    ].map(m => ({ label: m.label, urls: makeUrlCandidates(m.filename) }));

    const modeloSelect = document.getElementById("modeloSelect");
    modelos.forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m.label;
      opt.textContent = m.label;
      modeloSelect.appendChild(opt);
    });

    // =========================
    // CORES (DROPLIST)
    // =========================
    const CORES = [
      { key: "preto", label: "Preto", hex: "#000000" },
      { key: "prata", label: "Prata", hex: "#c6c7c9" },
      { key: "bronze1001", label: "Bronze 1001", hex: "#716859" },
      { key: "dourado", label: "Dourado", hex: "#B89C5D" },
      { key: "inox", label: "Inox", hex: "#918B82" },
    ];

    const corSelect = document.getElementById("corSelect");
    CORES.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = c.key;
      opt.textContent = c.label;
      corSelect.appendChild(opt);
    });
    corSelect.value = "preto"; // padr√£o

    // Cor atual aplicada ao modelo
    let currentColor = new THREE.Color(CORES.find(c => c.key === corSelect.value).hex);

    function applyColorToModel(root, color) {
      if (!root) return;

      root.traverse((n) => {
        if (!n.isMesh || !n.material) return;

        const mats = Array.isArray(n.material) ? n.material : [n.material];
        mats.forEach((m) => {
          if (!m) return;

          // tenta aplicar em materiais comuns
          if ("color" in m && m.color) {
            m.color.set(color);
          }
          // melhora leitura do material sob luz forte
          if ("metalness" in m) m.metalness = Math.max(0.4, m.metalness ?? 0.6);
          if ("roughness" in m) m.roughness = Math.min(0.55, m.roughness ?? 0.45);

          m.needsUpdate = true;
        });
      });

      logLine(`üé® Cor aplicada: ${color.getStyle ? color.getStyle() : color}`, "ok");
    }

    corSelect.addEventListener("change", () => {
      const c = CORES.find(x => x.key === corSelect.value) || CORES[0];
      currentColor = new THREE.Color(c.hex);
      if (currentModel) applyColorToModel(currentModel, currentColor);
    });

    // =========================
    // CAMERA CONTROLS (orbital simples)
    // =========================
    const cameraState = {
      isDragging: false,
      lastX: 0,
      lastY: 0,
      yaw: Math.PI / 4,
      pitch: Math.PI / 8,
      radius: 2.5,
      target: new THREE.Vector3(0, 0, 0)
    };

    function atualizarCamera() {
      const maxPitch = Math.PI / 2 - 0.05;
      const minPitch = -maxPitch;
      cameraState.pitch = Math.max(minPitch, Math.min(maxPitch, cameraState.pitch));

      const x = cameraState.radius * Math.cos(cameraState.pitch) * Math.cos(cameraState.yaw);
      const y = cameraState.radius * Math.sin(cameraState.pitch);
      const z = cameraState.radius * Math.cos(cameraState.pitch) * Math.sin(cameraState.yaw);

      camera.position.set(
        cameraState.target.x + x,
        cameraState.target.y + y,
        cameraState.target.z + z
      );
      camera.lookAt(cameraState.target);
    }

    renderer.domElement.addEventListener("mousedown", (e) => {
      cameraState.isDragging = true;
      cameraState.lastX = e.clientX;
      cameraState.lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => cameraState.isDragging = false);
    window.addEventListener("mousemove", (e) => {
      if (!cameraState.isDragging) return;
      const dx = e.clientX - cameraState.lastX;
      const dy = e.clientY - cameraState.lastY;
      cameraState.lastX = e.clientX;
      cameraState.lastY = e.clientY;
      const s = 0.005;
      cameraState.yaw += dx * s;
      cameraState.pitch += dy * s;
      atualizarCamera();
    });
    renderer.domElement.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoom = 1 + e.deltaY * 0.001;
      cameraState.radius = Math.max(0.05, Math.min(5000, cameraState.radius * zoom));
      atualizarCamera();
    }, { passive: false });

    // =========================
    // MODEL LOAD + DEBUG VISUAL
    // =========================
    let currentModel = null;

    function limparModelo() {
      if (!currentModel) return;
      scene.remove(currentModel);

      currentModel.traverse((node) => {
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) node.material.forEach(m => m.dispose());
          else node.material.dispose();
        }
      });

      currentModel = null;

      if (boxHelper) {
        scene.remove(boxHelper);
        boxHelper.geometry.dispose();
        boxHelper.material.dispose();
        boxHelper = null;
      }

      logLine("üßπ Modelo anterior removido e recursos liberados.", "muted");
    }

    function countMeshes(root) {
      let meshes = 0;
      let mats = 0;
      root.traverse((n) => {
        if (n.isMesh) {
          meshes++;
          if (n.material) mats += Array.isArray(n.material) ? n.material.length : 1;
        }
      });
      return { meshes, mats };
    }

    function forceVisibleMaterials(root) {
      root.traverse((n) => {
        if (!n.isMesh) return;
        const mats = Array.isArray(n.material) ? n.material : [n.material];
        mats.forEach((m) => {
          if (!m) return;
          // garante que vai renderizar mesmo com doubleSide / transparency
          m.side = THREE.DoubleSide;
          m.transparent = !!m.transparent;
          m.depthWrite = true;
          m.needsUpdate = true;
          if (wireframeEnabled) m.wireframe = true;
        });
      });
    }

    function applyWireframe(root, enabled) {
      root.traverse((n) => {
        if (!n.isMesh) return;
        const mats = Array.isArray(n.material) ? n.material : [n.material];
        mats.forEach((m) => {
          if (!m) return;
          m.wireframe = enabled;
          m.needsUpdate = true;
        });
      });
    }

    // üî• Enquadramento real baseado em FOV + bounding box
    function frameObject(obj, fitOffset = 1.25) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      cameraState.target.copy(center);

      const maxSize = Math.max(size.x, size.y, size.z);
      const fov = THREE.MathUtils.degToRad(camera.fov);
      let distance = (maxSize / (2 * Math.tan(fov / 2))) * fitOffset;

      // evita camera colada
      if (!isFinite(distance) || distance <= 0) distance = 2.5;

      cameraState.radius = distance;

      logLine(`üìê BoundingBox size: x=${size.x.toFixed(6)} y=${size.y.toFixed(6)} z=${size.z.toFixed(6)}`, "muted");
      logLine(`üéØ Center: x=${center.x.toFixed(6)} y=${center.y.toFixed(6)} z=${center.z.toFixed(6)}`, "muted");
      logLine(`üé• Distance (frame): ${distance.toFixed(6)}`, "ok");

      atualizarCamera();
    }

    // üî• Auto-scale: faz o modelo ocupar "targetSize" unidades
    function autoScaleToTarget(obj, targetSize = 2.0) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);

      if (!isFinite(maxDim) || maxDim <= 0) {
        logLine("‚ö†Ô∏è N√£o consegui medir o tamanho do modelo (maxDim inv√°lido).", "warn");
        return;
      }

      const scale = targetSize / maxDim;
      obj.scale.multiplyScalar(scale);

      logLine(`üß∑ Auto-scale aplicado. maxDim=${maxDim.toFixed(6)} -> scale=${scale.toFixed(6)}`, "ok");
    }

    async function testFetch(url) {
      try {
        const abs = new URL(url, window.location.href).toString();
        logLine(`üß™ Fetch test: ${url}  ->  ${abs}`, "muted");
        const r = await fetch(abs, { cache: "no-store" });
        logLine(`   ‚Ü≥ status: ${r.status} ${r.statusText}`, r.ok ? "ok" : "err");
        const buf = await r.arrayBuffer();
        logLine(`   ‚Ü≥ bytes: ${buf.byteLength}`, r.ok ? "ok" : "err");
        return r.ok ? abs : null;
      } catch (e) {
        logLine(`   ‚Ü≥ fetch falhou: ${String(e?.message || e)}`, "err");
        return null;
      }
    }

    async function carregarModelo(label, urls) {
      limparModelo();

      logLine(`üîé Testando URLs do modelo: ${label}`, "muted");
      let firstGoodAbs = null;

      for (const u of urls) {
        const abs = await testFetch(u);
        if (abs && !firstGoodAbs) firstGoodAbs = abs;
      }

      if (!firstGoodAbs) {
        logLine("‚ùå Nenhuma URL respondeu OK. Isso √© caminho/hosting.", "err");
        return;
      }

      logLine(`‚úÖ Vou carregar pelo primeiro OK: ${firstGoodAbs}`, "ok");
      logLine(`‚è≥ loader.load(${firstGoodAbs})`, "muted");

      loader.load(
        firstGoodAbs,
        (gltf) => {
          currentModel = gltf.scene;
          scene.add(currentModel);

          const { meshes, mats } = countMeshes(currentModel);
          logLine(`üß© Model stats: meshes=${meshes}, materials=${mats}`, "muted");

          // Se vier com escala min√∫scula, explode pra um tamanho bom
          autoScaleToTarget(currentModel, 2.0);

          // materiais sempre vis√≠veis
          forceVisibleMaterials(currentModel);

          // aplica cor selecionada (mesma para todos os modelos)
          applyColorToModel(currentModel, currentColor);

          // BoxHelper pra voc√™ VER, mesmo se material estiver zoado
          boxHelper = new THREE.BoxHelper(currentModel, 0x00ff88);
          boxHelper.visible = boxEnabled;
          scene.add(boxHelper);

          // enquadra certinho
          frameObject(currentModel, 1.35);

          logLine(`‚úÖ Modelo carregado: ${label}`, "ok");
          logLine(`‚ÑπÔ∏è Scene children: ${scene.children.length}`, "muted");
        },
        (xhr) => {
          if (!xhr || !xhr.total) {
            logLine("‚¨áÔ∏è Progresso: carregando (sem total dispon√≠vel)...", "muted");
            return;
          }
          const pct = (xhr.loaded / xhr.total) * 100;
          logLine(`‚¨áÔ∏è Progresso: ${pct.toFixed(1)}% (${xhr.loaded}/${xhr.total})`, "muted");
        },
        (err) => {
          logLine("‚ùå Erro no loader.load().", "err");
          logLine(String(err?.message || err), "err");
          console.error(err);
        }
      );
    }

    // =========================
    // UI EVENTS
    // =========================
    modeloSelect.addEventListener("change", async (e) => {
      const m = modelos.find(x => x.label === e.target.value) || modelos[0];
      await carregarModelo(m.label, m.urls);
    });

    document.getElementById("btnTestGLB").addEventListener("click", async () => {
      const m = modelos.find(x => x.label === modeloSelect.value) || modelos[0];
      logLine("üß™ Teste manual de fetch nas URLs...", "warn");
      for (const u of m.urls) await testFetch(u);
      logLine("üß™ Fim do teste manual.", "warn");
    });

    document.getElementById("resetCamera").addEventListener("click", () => {
      cameraState.yaw = Math.PI / 4;
      cameraState.pitch = Math.PI / 8;
      cameraState.radius = 2.5;
      cameraState.target.set(0, 0, 0);
      atualizarCamera();
      logLine("üé• C√¢mera resetada.", "ok");
    });

    document.getElementById("btnFrame").addEventListener("click", () => {
      if (!currentModel) return logLine("‚ö†Ô∏è Sem modelo pra enquadrar.", "warn");
      frameObject(currentModel, 1.35);
      logLine("üìå Enquadrado.", "ok");
    });

    document.getElementById("btnToggleWire").addEventListener("click", () => {
      wireframeEnabled = !wireframeEnabled;
      if (currentModel) applyWireframe(currentModel, wireframeEnabled);
      logLine(`üß± Wireframe: ${wireframeEnabled ? "ON" : "OFF"}`, wireframeEnabled ? "ok" : "muted");
    });

    document.getElementById("btnToggleBox").addEventListener("click", () => {
      boxEnabled = !boxEnabled;
      if (boxHelper) boxHelper.visible = boxEnabled;
      logLine(`üì¶ BoxHelper: ${boxEnabled ? "ON" : "OFF"}`, boxEnabled ? "ok" : "muted");
    });

    document.getElementById("btnToggleGrid").addEventListener("click", () => {
      gridEnabled = !gridEnabled;
      grid.visible = gridEnabled;
      axes.visible = gridEnabled;
      logLine(`üß≠ Grid/Axes: ${gridEnabled ? "ON" : "OFF"}`, gridEnabled ? "ok" : "muted");
    });

    window.addEventListener("resize", () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
      logLine("üìê Resize OK.", "muted");
    });

    // =========================
    // RENDER LOOP
    // =========================
    function animate() {
      requestAnimationFrame(animate);
      if (boxHelper && currentModel) boxHelper.update();
      renderer.render(scene, camera);
    }

    atualizarCamera();
    animate();

    // =========================
    // START
    // =========================
    modeloSelect.value = modelos[0].label;
    await carregarModelo(modelos[0].label, modelos[0].urls);
  </script>
</body>
</html>




